#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>

#define ECG_PIN A0 // ECG sensor input pin (AD8232)

// BLE characteristic to send ECG data
BLECharacteristic *pCharacteristic;
bool deviceConnected = false;
unsigned long previousMillis = 0;
const unsigned long samplingInterval = 10; // 10 ms for 100 Hz sampling rate

// Variables for heart rate calculation
unsigned long lastRPeakTime = 0;
float heartRate = 0;
unsigned long rPeakInterval = 0; // Time between successive R-peaks in ms

// Filter-related variables (Butterworth filter coefficients)
#define SAMPLE_RATE 100 // 100 Hz sample rate
#define CUTOFF_FREQ 1   // 1 Hz cutoff frequency (for ECG)
float a0 = 0.2929, a1 = 0.5858, a2 = 0.2929; // Butterworth filter coefficients
float prevInput[2] = {0.0, 0.0};
float prevOutput[2] = {0.0, 0.0};

int butterworthFilter(int input) {
    float output = a0 * input + a1 * prevInput[0] + a2 * prevInput[1] - 0.0 * prevOutput[0] - 0.1716 * prevOutput[1];

    // Shift inputs and outputs for next cycle
    prevInput[1] = prevInput[0];
    prevInput[0] = input;
    prevOutput[1] = prevOutput[0];
    prevOutput[0] = output;

    return (int)output;
}

// Heart rate smoothing variables (averaging over 5 measurements)
#define HEART_RATE_SMOOTHING_INTERVAL 5
float heartRateValues[HEART_RATE_SMOOTHING_INTERVAL];
int heartRateIndex = 0;

void smoothHeartRate(float newHeartRate) {
    heartRateValues[heartRateIndex] = newHeartRate;
    heartRateIndex = (heartRateIndex + 1) % HEART_RATE_SMOOTHING_INTERVAL;

    // Calculate average heart rate
    float sum = 0;
    for (int i = 0; i < HEART_RATE_SMOOTHING_INTERVAL; i++) {
        sum += heartRateValues[i];
    }
    heartRate = sum / HEART_RATE_SMOOTHING_INTERVAL;
}

// BLE server callback class
class MyServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
        deviceConnected = true;
        Serial.println("Client connected");
    };

    void onDisconnect(BLEServer* pServer) {
        deviceConnected = false;
        Serial.println("Client disconnected");
        BLEDevice::startAdvertising();
    }
};

// R-Peak detection (Pan-Tompkins style)
void detectRPeak(int ecgValue) {
    static int prevECGValue = 0;
    static int prevECGValue2 = 0;
    static int derivative = 0;
    static int threshold = 1000;

    // Calculate the derivative (difference between consecutive ECG samples)
    derivative = ecgValue - prevECGValue;

    // Check if this is an R-peak
    if (derivative > threshold && prevECGValue > 0) {
        unsigned long currentMillis = millis();
        rPeakInterval = currentMillis - lastRPeakTime;
        lastRPeakTime = currentMillis;

        // Calculate heart rate in BPM (beats per minute)
        if (rPeakInterval > 0) {
            float newHeartRate = 60000.0 / rPeakInterval;
            smoothHeartRate(newHeartRate); // Smooth heart rate over several R-peaks
        }
    }

    prevECGValue2 = prevECGValue;
    prevECGValue = ecgValue;
}

void setup() {
    Serial.begin(115200);
    pinMode(ECG_PIN, INPUT);

    // Initialize BLE
    BLEDevice::init("ECG_Device");
    BLEServer *pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());

    // Create Heart Rate Service
    BLEService *pService = pServer->createService(BLEUUID("0000180d-0000-1000-8000-00805f9b34fb"));

    // Create Heart Rate Measurement Characteristic
    pCharacteristic = pService->createCharacteristic(
                                        BLEUUID("00002a37-0000-1000-8000-00805f9b34fb"),
                                        BLECharacteristic::PROPERTY_READ |
                                        BLECharacteristic::PROPERTY_NOTIFY);

    pCharacteristic->addDescriptor(new BLE2902());

    // Start the service
    pService->start();

    // Start advertising
    BLEAdvertising *pAdvertising = pServer->getAdvertising();
    pAdvertising->addServiceUUID(BLEUUID("0000180d-0000-1000-8000-00805f9b34fb"));
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);
    pAdvertising->setMinPreferred(0x12);
    BLEDevice::startAdvertising();
    Serial.println("Waiting for a client to connect...");
}

void loop() {
    if (deviceConnected) {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= samplingInterval) {
            previousMillis = currentMillis;

            int rawECG = analogRead(ECG_PIN); // Read raw ECG value

            // Apply Butterworth filter to clean ECG data
            int filteredECG = butterworthFilter(rawECG);

            // Detect R-peak and calculate heart rate
            detectRPeak(filteredECG);

            // Send ECG data and heart rate to the client
            uint8_t data[5];
            data[0] = filteredECG & 0xFF; // Lower byte of ECG value
            data[1] = (filteredECG >> 8) & 0xFF; // Higher byte of ECG value
            data[2] = (heartRate > 0) ? (int)heartRate : 0; // Heart rate value
            data[3] = rPeakInterval & 0xFF; // Lower byte of R-peak interval
            data[4] = (rPeakInterval >> 8) & 0xFF; // Higher byte of R-peak interval

            pCharacteristic->setValue(data, 5);
            pCharacteristic->notify();

            // Print filtered ECG and heart rate data
            Serial.printf("ECG: %d, Heart Rate: %.2f BPM\n", filteredECG, heartRate);
        }
    }
}
